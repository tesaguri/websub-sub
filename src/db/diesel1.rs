#[doc(inline)]
pub use crate::diesel1_define_connection as define_connection;

// XXX: We could think of a version of this macro which does not take `$table` argument and uses
// `<$id as Column>::Table` in place of `$table`. In practice, however, that would somehow confuse
// rustc while resolving requirement of `ColumnInsertValue<id, Bound<..>>: InsertValues<table, _>`.
// Also, `{table_name}::table` type generated by `diesel::table!` does not implement `Default` so we
// would have no way to instanciate `$id::Table` anyway.
#[macro_export]
macro_rules! diesel1_define_connection {
    // This may not be the most concise way of defining a macro of this sort (you could do
    // something like `$($vis1 $kw1 $Name1; $($vis2 $kw2 $Name2;)?)?` for example), but the
    // documentation is the easiest to understand this way.
    (
        $table:path {
            $($column:tt: $path:path),* $(,)?
        }
        $(#[$conn_attr:meta])*
        $conn_vis:vis connection $Connection:ident;
        $(#[$pool_attr:meta])*
        $pool_vis:vis pool $Pool:ident;
    ) => {
        $crate::_diesel1_define_connection_inner! {
            $table { $($column: $path,)* }
            $(#[$conn_attr])* $conn_vis $Connection;
            $(#[$pool_attr])* $pool_vis $Pool;
        }
    };
    (
        $table:path {
            $($column:tt: $path:path),* $(,)?
        }
        $(#[$pool_attr:meta])*
        $pool_vis:vis pool $Pool:ident;
        $(#[$conn_attr:meta])*
        $conn_vis:vis connection $Connection:ident;
    ) => {
        $crate::_diesel1_define_connection_inner! {
            $table { $($column: $path,)* }
            $(#[$conn_attr])* $conn_vis $Connection;
            $(#[$pool_attr])* $pool_vis $Pool;
        }
    };
    (
        $table:path {
            $($column:tt: $path:path),* $(,)?
        }
        $(#[$conn_attr:meta])*
        $conn_vis:vis connection $Connection:ident;
    ) => {
        $crate::_diesel1_define_connection_inner! {
            $table { $($column: $path,)* }
            $(#[$conn_attr])* $conn_vis $Connection;
            pub(crate) Pool;
        }
    };
    (
        $table:path {
            $($column:tt: $path:path),* $(,)?
        }
        $(#[$pool_attr:meta])*
        $pool_vis:vis pool $Pool:ident;
    ) => {
        $crate::_diesel1_define_connection_inner! {
            $table { $($column: $path,)* }
            pub(crate) Connection;
            $(#[$pool_attr])* $pool_vis $Pool;
        }
    };
    (
        $table:path {
            $($column:tt: $path:path),* $(,)?
        }
    ) => {
        $crate::_diesel1_define_connection_inner! {
            $table { $($column: $path,)* }
            pub(crate) Connection;
            pub(crate) Pool;
        }
    };
}

#[macro_export]
#[doc(hidden)]
macro_rules! _diesel1_define_connection_inner {
    // Entry point:
    (
        $table:path { $($column:tt: $path:path),* $(,)? }
        $(#[$cattr:meta])* $cvis:vis $Connection:ident;
        $(#[$pattr:meta])* $pvis:vis $Pool:ident;
    ) => {
        $crate::_diesel1_define_connection_inner! {
            $table { $($column: $path,)* }
            id: @,
            hub: @,
            topic: @,
            secret: @,
            expires_at: @,
            $(#[$cattr])* $cvis $Connection,
            $(#[$pattr])* $pvis $Pool,
        }
    };
    // Parse columns:
    (
        $table:path { id: $id:path, $($rest:tt)* }
        id: @,
        hub: $hub:tt,
        topic: $topic:tt,
        secret: $secret:tt,
        expires_at: $expires_at:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner! {
            $table { $($rest)* }
            id: $id,
            hub: $hub,
            topic: $topic,
            secret: $secret,
            expires_at: $expires_at,
            $($items)+
        }
    };
    (
        $table:path { hub: $hub:path, $($rest:tt)* }
        id: $id:tt,
        hub: @,
        topic: $topic:tt,
        secret: $secret:tt,
        expires_at: $expires_at:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner! {
            $table { $($rest)* }
            id: $id,
            hub: $hub,
            topic: $topic,
            secret: $secret,
            expires_at: $expires_at,
            $($items)+
        }
    };
    (
        $table:path { topic: $topic:path, $($rest:tt)* }
        id: $id:tt,
        hub: $hub:tt,
        topic: @,
        secret: $secret:tt,
        expires_at: $expires_at:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner! {
            $table { $($rest)* }
            id: $id,
            hub: $hub,
            topic: $topic,
            secret: $secret,
            expires_at: $expires_at,
            $($items)+
        }
    };
    (
        $table:path { secret: $secret:path, $($rest:tt)* }
        id: $id:tt,
        hub: $hub:tt,
        topic: $topic:tt,
        secret: @,
        expires_at: $expires_at:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner! {
            $table { $($rest)* }
            id: $id,
            hub: $hub,
            topic: $topic,
            secret: $secret,
            expires_at: $expires_at,
            $($items)+
        }
    };
    (
        $table:path { expires_at: $expires_at:path, $($rest:tt)* }
        id: $id:tt,
        hub: $hub:tt,
        topic: $topic:tt,
        secret: $secret:tt,
        expires_at: @,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner! {
            $table { $($rest)* }
            id: $id,
            hub: $hub,
            topic: $topic,
            secret: $secret,
            expires_at: $expires_at,
            $($items)+
        }
    };
    // Handle erroneous inputs:
    // Duplicate columns:
    (
        $table:path { id: $_:path, $($rest:tt)* }
        id: $id:path,
        hub: $hub:tt,
        topic: $topic:tt,
        secret: $secret:tt,
        expires_at: $expires_at:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner!(@duplicate id);
        $crate::_diesel1_define_connection_inner! {
            $table { $($rest)* }
            id: $id,
            hub: $hub,
            topic: $topic,
            secret: $secret,
            expires_at: $expires_at,
            $($items)+
        }
    };
    (
        $table:path { hub: $_:path, $($rest:tt)* }
        id: $id:tt,
        hub: $hub:path,
        topic: $topic:tt,
        secret: $secret:tt,
        expires_at: $expires_at:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner!(@duplicate hub);
        $crate::_diesel1_define_connection_inner! {
            $table { $($rest)* }
            id: $id,
            hub: $hub,
            topic: $topic,
            secret: $secret,
            expires_at: $expires_at,
            $($items)+
        }
    };
    (
        $table:path { topic: $_:path, $($rest:tt)* }
        id: $id:tt,
        hub: $hub:tt,
        topic: $topic:path,
        secret: $secret:tt,
        expires_at: $expires_at:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner!(@duplicate topic);
        $crate::_diesel1_define_connection_inner! {
            $table { $($rest)* }
            id: $id,
            hub: $hub,
            topic: $topic,
            secret: $secret,
            expires_at: $expires_at,
            $($items)+
        }
    };
    (
        $table:path { secret: $_:path, $($rest:tt)* }
        id: $id:tt,
        hub: $hub:tt,
        topic: $topic:tt,
        secret: $secret:path,
        expires_at: $expires_at:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner!(@duplicate secret);
        $crate::_diesel1_define_connection_inner! {
            $table { $($rest)* }
            id: $id,
            hub: $hub,
            topic: $topic,
            secret: $secret,
            expires_at: $expires_at,
            $($items)+
        }
    };
    (
        $table:path { expires_at: $_:path, $($rest:tt)* }
        id: $id:tt,
        hub: $hub:tt,
        topic: $topic:tt,
        secret: $secret:tt,
        expires_at: $expires_at:path,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner!(@duplicate expires_at);
        $crate::_diesel1_define_connection_inner! {
            $table { $($rest)* }
            id: $id,
            hub: $hub,
            topic: $topic,
            secret: $secret,
            expires_at: $expires_at,
            $($items)+
        }
    };
    (@duplicate $column:ident) => {
        compile_error!(concat!("column for `", stringify!($column), "` specified more than once"));
    };
    // Unknown columns:
    (
        $table:path { $column:ident: $_:path, $($rest:tt)* }
        id: $id:tt,
        hub: $hub:tt,
        topic: $topic:tt,
        secret: $secret:tt,
        expires_at: $expires_at:tt,
        $($items:tt)+
    ) => {
        compile_error!(concat!("Unknown colum kind `", stringify!($column), "`"));
        $crate::_diesel1_define_connection_inner! {
            $table { $($rest)* }
            id: $id,
            hub: $hub,
            topic: $topic,
            secret: $secret,
            expires_at: $expires_at,
        }
    };
    // Missing columns:
    (
        $table:path {}
        id: @,
        hub: $_h:tt,
        topic: $_t:tt,
        secret: $_s:tt,
        expires_at: $_e:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner!(@missing $table, id);
    };
    (
        $table:path {}
        id: $_i:tt,
        hub: @,
        topic: $_t:tt,
        secret: $_s:tt,
        expires_at: $_e:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner!(@missing $table, hub);
    };
    (
        $table:path {}
        id: $_i:tt,
        hub: $_h:tt,
        topic: @,
        secret: $_s:tt,
        expires_at: $_e:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner!(@missing $table, topic);
    };
    (
        $table:path {}
        id: $_i:tt,
        hub: $_h:tt,
        topic: $_t:tt,
        secret: @,
        expires_at: $_e:tt,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner!(@missing $table, secret);
    };
    (
        $table:path {}
        id: $_i:tt,
        hub: $_h:tt,
        topic: $_t:tt,
        secret: $_s:tt,
        expires_at: @,
        $($items:tt)+
    ) => {
        $crate::_diesel1_define_connection_inner!(@missing $table, expires_at);
    };
    (@missing $table:path, $column:ident) => {
        compile_error!(concat!(
            "missing column for `",
            stringify!($column),
            "` in table `",
            stringify!($table),
            "`",
        ));
    };
    // Expand to output:
    (
        $table:path {}
        id: $id:path,
        hub: $hub:path,
        topic: $topic:path,
        secret: $secret:path,
        expires_at: $expires_at:path,
        $(#[$cattr:meta])* $cvis:vis $Connection:ident,
        $(#[$pattr:meta])* $pvis:vis $Pool:ident,
    ) => {
        $(#[$cattr])*
        $cvis struct $Connection<C> {
            inner: C,
        }

        $(#[$pattr])*
        $pvis struct $Pool<M>
        where
            M: $crate::_private::diesel1::r2d2::ManageConnection,
        {
            inner: $crate::_private::diesel1::r2d2::Pool<M>,
        }

        const _: () = {
            use std::mem;

            use $crate::_private::diesel1 as diesel;
            use $crate::_private::rand;

            use diesel::backend::Backend;
            use diesel::deserialize::FromSql;
            use diesel::dsl::*;
            use diesel::expression::bound::Bound;
            use diesel::insertable::{ColumnInsertValue, InsertValues};
            use diesel::prelude::*;
            use diesel::r2d2::{ManageConnection, PooledConnection};
            use diesel::sql_types::{self, HasSqlType};
            use rand::RngCore;

            use self::{Connection, Pool};

            impl<C: diesel::Connection> Connection<C>
            where
                C::Backend: Backend + HasSqlType<sql_types::Bool> + 'static,
                i64: FromSql<sql_types::BigInt, C::Backend>,
                bool: FromSql<sql_types::Bool, C::Backend>,
                *const str: FromSql<sql_types::Text, C::Backend>,
                // XXX: Can we remove these `#[doc(hidden)]` types? These bounds are required for
                // `insert_into(table).values((id.eq(_), hub.eq(_), topic.eq(_), secret.eq(_)))`
                // to implement `ExecuteDsl<C>`. These traits are implemented differently between
                // SQLite and other backends and there seems to be no concise way to be generic over
                // them.
                ColumnInsertValue<$id, Bound<sql_types::BigInt, i64>>:
                    InsertValues<$table, C::Backend>,
                for<'a> ColumnInsertValue<$hub, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, C::Backend>,
                for<'a> ColumnInsertValue<$topic, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, C::Backend>,
                for<'a> ColumnInsertValue<$secret, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, C::Backend>,
            {
                pub fn new(connection: C) -> Self {
                    Connection { inner: connection }
                }
            }

            impl<C: diesel::Connection> $crate::db::Connection for Connection<C>
            where
                C::Backend: Backend + HasSqlType<sql_types::Bool> + 'static,
                i64: FromSql<sql_types::BigInt, C::Backend>,
                bool: FromSql<sql_types::Bool, C::Backend>,
                *const str: FromSql<sql_types::Text, C::Backend>,
                ColumnInsertValue<$id, Bound<sql_types::BigInt, i64>>:
                    InsertValues<$table, C::Backend>,
                for<'a> ColumnInsertValue<$hub, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, C::Backend>,
                for<'a> ColumnInsertValue<$topic, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, C::Backend>,
                for<'a> ColumnInsertValue<$secret, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, C::Backend>,
            {
                type Error = diesel::result::Error;

                fn transaction<T, F>(&self, f: F) -> Result<T, Self::Error>
                where
                    F: FnOnce() -> Result<T, Self::Error>,
                {
                    self.inner.transaction(f)
                }

                fn create_subscription(&self, hub: &str, topic: &str, secret: &str)
                    -> QueryResult<u64>
                {
                    let mut rng = rand::thread_rng();
                    self.transaction(|| loop {
                        let id = rng.next_u64();
                        let result = diesel::insert_into($table)
                            .values((
                                $id.eq(id as i64),
                                $hub.eq(hub),
                                $topic.eq(topic),
                                $secret.eq(secret),
                            ))
                            .execute(&self.inner);
                        match result {
                            Ok(_) => return Ok(id),
                            Err(diesel::result::Error::DatabaseError(
                                diesel::result::DatabaseErrorKind::UniqueViolation,
                                _,
                            )) => {} // retry
                            Err(e) => return Err(e),
                        }
                    })
                }

                fn get_topic(&self, id: u64) -> QueryResult<Option<(String, String)>> {
                    $table
                        .select(($topic, $secret))
                        .find(id as i64)
                        .get_result::<(String, String)>(&self.inner)
                        .optional()
                }

                fn subscription_exists(&self, id: u64, topic: &str) -> QueryResult<bool> {
                    diesel::select(exists(
                        $table
                            .find(id as i64)
                            .filter($topic.eq(topic)),
                    ))
                    .get_result(&self.inner)
                }

                fn get_subscriptions_expire_before(
                    &self,
                    before: i64,
                ) -> QueryResult<Vec<(i64, String, String)>> {
                    $table
                        .filter($expires_at.le(before))
                        .select(($id, $hub, $topic))
                        .load::<(i64, String, String)>(&self.inner)
                }

                fn get_hub_of_inactive_subscription(
                    &self,
                    id: u64,
                    topic: &str,
                ) -> QueryResult<Option<String>> {
                    $table
                        .find(id as i64)
                        .filter($topic.eq(topic))
                        .filter($expires_at.is_null())
                        .select($hub)
                        .get_result(&self.inner)
                        .optional()
                }

                fn get_old_subscriptions(&self, id: u64, hub: &str, topic: &str)
                    -> QueryResult<Vec<u64>>
                {
                    let vec: Vec<i64> = $table
                        .filter($hub.eq(&hub))
                        .filter($topic.eq(&topic))
                        .filter(not($id.eq(id as i64)))
                        .select($id)
                        .load(&self.inner)?;
                    let mut vec = mem::ManuallyDrop::new(vec);
                    let (ptr, length, capacity) = (vec.as_mut_ptr(), vec.len(), vec.capacity());
                    // Safety: `u64` has the same size and alignment as `i64`.
                    let vec = unsafe { Vec::from_raw_parts(ptr.cast::<u64>(), length, capacity) };
                    Ok(vec)
                }

                fn activate_subscription(&self, id: u64, expires_at: i64) -> QueryResult<bool> {
                    diesel::update($table.find(id as i64))
                        .set($expires_at.eq(expires_at))
                        .execute(&self.inner)
                        .map(|n| n != 0)
                }

                fn deactivate_subscriptions_expire_before(&self, before: i64) -> QueryResult<()> {
                    diesel::update($table.filter($expires_at.le(before)))
                        .set($expires_at.eq(None::<i64>))
                        .execute(&self.inner)
                        .map(|_| ())
                }

                fn delete_subscriptions(&self, id: u64) -> QueryResult<bool> {
                    diesel::delete($table.find(id as i64))
                        .execute(&self.inner)
                        .map(|n| n != 0)
                }

                fn get_next_expiry(&self) -> QueryResult<Option<i64>> {
                    $table
                        .select($expires_at)
                        .filter($expires_at.is_not_null())
                        .order($expires_at.asc())
                        .first::<Option<i64>>(&self.inner)
                        .optional()
                        .map(Option::flatten)
                }
            }

            impl<C> Connection<C> {
                pub fn into_inner(self) -> C {
                    self.inner
                }
            }

            impl<C> AsRef<C> for Connection<C> {
                fn as_ref(&self) -> &C {
                    &self.inner
                }
            }

            impl<M: ManageConnection> Pool<M>
            where
                PooledConnection<M>: diesel::Connection,
                <PooledConnection<M> as diesel::Connection>::Backend:
                    Backend + HasSqlType<sql_types::Bool> + 'static,
                bool: FromSql<
                    sql_types::Bool,
                    <PooledConnection<M> as diesel::Connection>::Backend,
                >,
                i64: FromSql<
                    sql_types::BigInt,
                    <PooledConnection<M> as diesel::Connection>::Backend,
                >,
                *const str: FromSql<
                    sql_types::Text,
                    <PooledConnection<M> as diesel::Connection>::Backend,
                >,
                ColumnInsertValue<$id, Bound<sql_types::BigInt, i64>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
                for<'a> ColumnInsertValue<$hub, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
                for<'a> ColumnInsertValue<$topic, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
                for<'a> ColumnInsertValue<$secret, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
            {
                pub fn new(manager: M) -> Result<Self, diesel::r2d2::PoolError> {
                    diesel::r2d2::Pool::new(manager).map(Pool::from)
                }
            }

            impl<M: ManageConnection> Pool<M> {
                pub fn into_inner(self) -> diesel::r2d2::Pool<M> {
                    self.inner
                }
            }

            impl<M: ManageConnection> AsRef<diesel::r2d2::Pool<M>> for Pool<M> {
                fn as_ref(&self) -> &diesel::r2d2::Pool<M> {
                    &self.inner
                }
            }

            impl<M: ManageConnection> From<diesel::r2d2::Pool<M>> for Pool<M>
            where
                PooledConnection<M>: diesel::Connection,
                <PooledConnection<M> as diesel::Connection>::Backend:
                    Backend + HasSqlType<sql_types::Bool> + 'static,
                bool: FromSql<
                    sql_types::Bool,
                    <PooledConnection<M> as diesel::Connection>::Backend,
                >,
                i64: FromSql<
                    sql_types::BigInt,
                    <PooledConnection<M> as diesel::Connection>::Backend,
                >,
                *const str: FromSql<
                    sql_types::Text,
                    <PooledConnection<M> as diesel::Connection>::Backend,
                >,
                ColumnInsertValue<$id, Bound<sql_types::BigInt, i64>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
                for<'a> ColumnInsertValue<$hub, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
                for<'a> ColumnInsertValue<$topic, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
                for<'a> ColumnInsertValue<$secret, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
            {
                fn from(pool: diesel::r2d2::Pool<M>) -> Self {
                    Pool { inner: pool }
                }
            }

            impl<M: ManageConnection> Clone for Pool<M> {
                fn clone(&self) -> Self {
                    Pool {
                        inner: self.inner.clone(),
                    }
                }
            }

            impl<M: ManageConnection> $crate::db::Pool for Pool<M>
            where
                PooledConnection<M>: diesel::Connection,
                <PooledConnection<M> as diesel::Connection>::Backend:
                    Backend + HasSqlType<sql_types::Bool> + 'static,
                bool: FromSql<
                    sql_types::Bool,
                    <PooledConnection<M> as diesel::Connection>::Backend,
                >,
                i64: FromSql<
                    sql_types::BigInt,
                    <PooledConnection<M> as diesel::Connection>::Backend,
                >,
                *const str: FromSql<
                    sql_types::Text,
                    <PooledConnection<M> as diesel::Connection>::Backend,
                >,
                ColumnInsertValue<$id, Bound<sql_types::BigInt, i64>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
                for<'a> ColumnInsertValue<$hub, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
                for<'a> ColumnInsertValue<$topic, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
                for<'a> ColumnInsertValue<$secret, Bound<sql_types::Text, &'a str>>:
                    InsertValues<$table, <PooledConnection<M> as diesel::Connection>::Backend>,
            {
                type Connection = Connection<PooledConnection<M>>;
                type Error = diesel::r2d2::PoolError;

                fn get(&self) -> Result<Self::Connection, Self::Error> {
                    self.inner.get().map(|inner| Connection { inner })
                }
            }
        };
    };
}
